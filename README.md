这是一个使用C++实现的线程池项目。
线程池支持两种模式：固定线程数量和动态模式，其中初始数量为thread::hardware_concurrency() 建议可用于创建新线程的逻辑处理器的数量。
线程池中包含一个任务队列，用于存储待执行的任务。每个任务都有一个结果对象，任务执行完毕后，可以通过这个结果对象获取任务的执行结果。
## Version1.0 

ThreadPool：线程池类，管理一组线程和一个任务队列。

Thread：线程类，封装了一个线程的创建和启动。

Task：任务类，封装了一个要在线程池中执行的任务。

Any：自实现一个类似于std::any的功能,是一个可以存储任意类型数据的类，它内部使用了类型擦除技术，用于存储任务的执行结果。当任务执行完毕，其结果会被存储到一个Any对象中，然后这个Any对象会被存储到Result对象中。

Semaphore：自实现的信号量，用于控制对一定数量的资源的并发访问wait方法对应于acquire，用于获取一个资源；有一个post方法，对应于release，用于释放一个资源。

Result：用于存储和获取任务（Task）的执行结果。在类中，有一个Any类型的成员变量any_，用于存储任务的执行结果。类中还有一个Semaphore类型的成员变量sem_，用于实现对任务执行结果的同步访问。当任务还没有执行完毕时，其他线程（例如主线程）可以调用Result的get方法来获取任务的执行结果。如果此时任务还没有执行完毕，那么get方法会阻塞当前线程，直到任务执行完毕。这是通过Semaphore的wait方法实现的。当任务执行完毕，任务的执行结果会被存储到Result对象中，然后调用Semaphore的post方法来唤醒正在等待结果的线程。

## Version2.0 
submitTask函数进行了重构，引入std::future 和 std::packaged_task 。现在，submitTask函数返回一个std::future对象，可以使用这个对象来获取任务的执行结果。这是通过std::packaged_task来实现的，它是一个可以存储任意可调用对象的类模板，当你调用它的operator()时，它会调用存储的任务，并将结果存储到一个std::future对象中。
